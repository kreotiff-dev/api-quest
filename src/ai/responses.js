/**
 * Шаблоны ответов AI-ассистента
 * @module ai/responses
 */

/**
 * Предустановленные сообщения для различных ситуаций
 */
export const aiResponses = {
  welcome: "Здравствуйте! Я ваш AI-ассистент. Готов помочь с выполнением задания. Вы можете попросить помощь или анализ вашего решения в любой момент.",
  
  methodHelp: {
      GET: "Метод GET используется для получения данных с сервера. Он не должен содержать тело запроса и не изменяет состояние сервера.",
      POST: "Метод POST используется для отправки данных на сервер для создания нового ресурса. Обычно содержит тело запроса с данными.",
      PUT: "Метод PUT используется для полного обновления существующего ресурса. Содержит тело запроса с полными данными обновляемого ресурса.",
      PATCH: "Метод PATCH используется для частичного обновления существующего ресурса. Содержит тело запроса только с изменяемыми полями.",
      DELETE: "Метод DELETE используется для удаления ресурса на сервере. Обычно не содержит тело запроса."
  },
  
  headerHelp: {
      "Content-Type": "Заголовок Content-Type указывает формат тела запроса. Для JSON используйте 'application/json'.",
      "Authorization": "Заголовок Authorization используется для передачи учетных данных для аутентификации на сервере.",
      "X-API-Key": "Заголовок X-API-Key используется для передачи API-ключа для доступа к защищенным ресурсам."
  },
  
  statusCodes: {
      200: "200 OK: Успешный запрос. Сервер вернул запрошенные данные.",
      201: "201 Created: Ресурс успешно создан. Используется после успешного POST-запроса.",
      204: "204 No Content: Запрос выполнен успешно, но сервер не вернул данные.",
      400: "400 Bad Request: Сервер не может обработать запрос из-за ошибки клиента (например, неверный формат данных).",
      401: "401 Unauthorized: Требуется аутентификация. Клиент не предоставил необходимые учетные данные.",
      403: "403 Forbidden: Сервер понял запрос, но отказывается его выполнять из-за отсутствия прав доступа.",
      404: "404 Not Found: Запрашиваемый ресурс не найден на сервере.",
      500: "500 Internal Server Error: Внутренняя ошибка сервера. Сервер столкнулся с неожиданной ошибкой."
  },
  
  analysisSuccess: "Ваш запрос выглядит правильно! Все необходимые элементы присутствуют.",
  analysisFailed: "В вашем запросе есть проблемы, которые нужно исправить:",
  
  hints: {
      general: "Внимательно прочитайте требования задания. Проверьте метод, URL и заголовки.",
      json: "Убедитесь, что ваше JSON-тело запроса правильно форматировано и содержит все необходимые поля.",
      headers: "Не забудьте добавить все необходимые заголовки. Для запросов с телом обычно требуется заголовок Content-Type.",
      auth: "Для доступа к защищенным ресурсам необходима аутентификация. Проверьте, правильно ли вы передаете API-ключ или токен."
  },
  
  apiSources: {
    mock: "Симулятор API предоставляет локальные моки для обучения без внешних зависимостей. Это самый надежный источник, так как не требует подключения к интернету и всегда доступен.",
    public: "Публичные API позволяют практиковаться с реальными данными и изучать особенности работы с внешними сервисами. Однако они могут быть недоступны или иметь ограничения на количество запросов.",
    custom: "Учебный API платформы предоставляет расширенные возможности для обучения, включая авторизацию, валидацию данных и более сложные сценарии использования API."
},

sourceSelection: "Для выбора источника API используйте селектор в верхней части экрана. Некоторые задания могут требовать использования конкретного источника API.",

sourceComparison: `<p>Разные источники API могут иметь особенности:</p>
                  <ul>
                    <li><strong>Симулятор API</strong>: Предсказуемые ответы, всегда доступен, идеален для начинающих</li>
                    <li><strong>Публичные API</strong>: Реальные данные, могут быть ограничения, помогают понять особенности внешних сервисов</li>
                    <li><strong>Учебный API</strong>: Продвинутые функции, требует авторизации, более сложные сценарии</li>
                  </ul>`,

troubleshooting: `<p>Если у вас проблемы с источниками API:</p>
                 <ol>
                   <li>Проверьте подключение к интернету для публичных и учебных API</li>
                   <li>Убедитесь, что вы авторизованы для доступа к учебному API</li>
                   <li>Временно переключитесь на симулятор API, если внешние источники недоступны</li>
                   <li>Проверьте, соответствует ли выбранный источник требованиям задания</li>
                 </ol>`
};

/**
* Получение ответа AI-ассистента
* @param {string} key - Ключ ответа (например, 'welcome')
* @param {any} [params] - Параметры для форматирования ответа
* @returns {string} Отформатированный ответ
*/
export function getResponse(key, params) {
// Разделяем ключ на части (например, 'methodHelp.GET')
const keyParts = key.split('.');

// Получаем базовый объект ответов
let response = aiResponses;

// Проходим по частям ключа
for (const part of keyParts) {
    if (response && response[part]) {
        response = response[part];
    } else {
        return `Ответ с ключом '${key}' не найден`;
    }
}

// Если ответ - функция, вызываем её с параметрами
if (typeof response === 'function') {
    return response(params);
}

// Если ответ - строка, и есть параметры, форматируем строку
if (typeof response === 'string' && params) {
    return formatResponse(response, params);
}

return response;
}

/**
* Форматирование строки ответа с параметрами
* @param {string} template - Шаблон ответа
* @param {Object} params - Параметры для форматирования
* @returns {string} Отформатированный ответ
*/
function formatResponse(template, params) {
// Заменяем плейсхолдеры в шаблоне на значения параметров
return template.replace(/\{(\w+)\}/g, (match, key) => {
    return params[key] !== undefined ? params[key] : match;
});
}

/**
* Генерация случайного ответа из массива возможных ответов
* @param {Array<string>} responses - Массив возможных ответов
* @returns {string} Случайный ответ
*/
export function getRandomResponse(responses) {
if (!Array.isArray(responses) || responses.length === 0) {
    return 'Нет доступных ответов';
}

const index = Math.floor(Math.random() * responses.length);
return responses[index];
}

export default {
aiResponses,
getResponse,
getRandomResponse
};